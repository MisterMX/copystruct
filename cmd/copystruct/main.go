package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"go/types"
	"log"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: copystruct <source-package> <output-file> <struct-name>,[<struct-name>,...]")
		os.Exit(1)
	}
	srcPkg := os.Args[1]
	outFile := os.Args[2]
	rootNames := strings.Split(os.Args[3], ",")

	fset := token.NewFileSet()
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedImports,
		Fset: fset,
	}
	pkgs, err := packages.Load(cfg, srcPkg)
	if err != nil {
		log.Fatalf("packages.Load: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		log.Fatalf("errors loading package")
	}
	pkg := pkgs[0]

	// Map: type name -> *ast.TypeSpec and parent *ast.GenDecl
	typeSpecs := map[string]*ast.TypeSpec{}
	parentGen := map[string]*ast.GenDecl{}
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, s := range gd.Specs {
				ts, ok := s.(*ast.TypeSpec)
				if !ok {
					continue
				}
				typeSpecs[ts.Name.Name] = ts
				parentGen[ts.Name.Name] = gd
			}
		}
	}

	// Collect imports referenced (path -> alias)
	imports := map[string]string{}

	// toCopy set and insertion-ordered list
	toCopy := map[string]bool{}
	var order []string
	addType := func(name string) {
		if !toCopy[name] {
			toCopy[name] = true
			order = append(order, name)
		}
	}

	for _, rootName := range rootNames {
		if typeSpecs[rootName] == nil {
			log.Fatalf("type %q not found in package %s", rootName, srcPkg)
		}

		// recursive collector
		var collectExpr func(ast.Expr)
		collectExpr = func(e ast.Expr) {
			switch t := e.(type) {
			case *ast.Ident:
				// named type in same package?
				if _, ok := typeSpecs[t.Name]; ok {
					addType(t.Name)
				}
			case *ast.StarExpr:
				collectExpr(t.X)
			case *ast.ArrayType:
				collectExpr(t.Elt)
			case *ast.MapType:
				collectExpr(t.Key)
				collectExpr(t.Value)
			case *ast.ChanType:
				collectExpr(t.Value)
			case *ast.StructType:
				if t.Fields != nil {
					for _, f := range t.Fields.List {
						collectExpr(f.Type)
					}
				}
			case *ast.SelectorExpr:
				// external package type like `pkg.Type`
				if id, ok := t.X.(*ast.Ident); ok {
					if obj := pkg.TypesInfo.ObjectOf(id); obj != nil {
						if pn, ok := obj.(*types.PkgName); ok {
							pth := pn.Imported().Path()
							alias := id.Name // preserve the local name used in source
							// if alias equals default base name, we can omit alias when printing
							imports[pth] = alias
						}
					}
				}
				// We don't attempt to copy external types
			case *ast.InterfaceType:
				// nothing to import beyond nested types in method sigs (skip for brevity)
			case *ast.FuncType:
				// inspect params/results
				if t.Params != nil {
					for _, f := range t.Params.List {
						collectExpr(f.Type)
					}
				}
				if t.Results != nil {
					for _, f := range t.Results.List {
						collectExpr(f.Type)
					}
				}
			default:
				// other node kinds: ignore
			}
		}

		collectFromStruct := func(st *ast.StructType) {
			if st == nil || st.Fields == nil {
				return
			}
			for _, f := range st.Fields.List {
				collectExpr(f.Type)
			}
		}

		// BFS-like expansion starting from rootName
		addType(rootName)
		for i := 0; i < len(order); i++ {
			name := order[i]
			ts := typeSpecs[name]
			if ts == nil {
				continue
			}
			// if underlying type is a struct, explore fields
			if st, ok := ts.Type.(*ast.StructType); ok {
				collectFromStruct(st)
			} else {
				// if the type is an alias or named type, still attempt to inspect the type expression
				collectExpr(ts.Type)
			}
		}
	}

	outFileAbs, err := filepath.Abs(outFile)
	if err != nil {
		log.Fatalf("cannot get absolute output filepath: %v", err)
	}
	outDir := filepath.Dir(outFileAbs)
	outPkgName := filepath.Base(outDir)

	// Build source
	buf := &bytes.Buffer{}
	fmt.Fprint(buf, "// Code generated by copystruct. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "package %s\n\n", outPkgName)

	// write imports if any (sorted)
	if len(imports) > 0 {
		paths := make([]string, 0, len(imports))
		for p := range imports {
			paths = append(paths, p)
		}
		sort.Strings(paths)

		fmt.Fprint(buf, "import (\n")
		for _, p := range paths {
			alias := imports[p]
			base := path.Base(p)
			// decide whether to print alias or default import
			if alias == "" || alias == base {
				fmt.Fprintf(buf, "\t%q\n", p)
			} else {
				fmt.Fprintf(buf, "\t%s %q\n", alias, p)
			}
		}
		fmt.Fprint(buf, ")\n\n")
	}

	// Print the collected type decls in the discovered order.
	// We print a GenDecl that has a single spec (the TypeSpec) so we don't accidentally print
	// other types from the same type-group declaration.
	for _, name := range order {
		ts := typeSpecs[name]
		if ts == nil {
			continue
		}
		gd := parentGen[name]
		newDecl := &ast.GenDecl{
			Doc:    gd.Doc, // preserve the doc comment on the original GenDecl (if any)
			Tok:    token.TYPE,
			TokPos: gd.TokPos,
			Specs:  []ast.Spec{ts},
		}
		// Use printer.Fprint to write the decl (comments attached to nodes are preserved via Doc/Field.Doc/Field.Comment).
		if err := printer.Fprint(buf, fset, newDecl); err != nil {
			log.Fatalf("printer.Fprint: %v", err)
		}
		fmt.Fprint(buf, "\n\n")
	}

	// Format output
	outSrc, err := format.Source(buf.Bytes())
	if err != nil {
		// if formatting fails, write the unformatted output to help debugging
		log.Printf("format.Source failed: %v", err)
		outSrc = buf.Bytes()
	}

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		log.Fatalf("mkdir outdir: %v", err)
	}
	if err := os.WriteFile(outFile, outSrc, 0o644); err != nil {
		log.Fatalf("write file: %v", err)
	}
}
