package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/printer"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

// copycode copies Go source files from a source package into an output directory,
// rewriting the package clause to match the output directory's base name.
// Usage: copycode <source-package> <output-dir> [<file>,<file>,...]
// If an optional comma separated list of filenames (without .go) is provided,
// only those files are copied (non-test files). Otherwise all non-test files are copied.
func main() {
	var includeTests bool
	flag.BoolVar(&includeTests, "tests", false, "include files ending with _test.go when copying")
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 || len(args) > 3 {
		fmt.Println("Usage: copycode [ --tests ] <source-package> <output-dir> [<file1>,<file2>,...]")
		os.Exit(1)
	}
	srcPkg := args[0]
	outDirInput := args[1]

	outDir, err := filepath.Abs(outDirInput)
	if err != nil {
		log.Fatalf("realpath outdir: %v", err)
	}

	var filter map[string]bool
	if len(args) == 3 {
		filter = make(map[string]bool)
		for _, f := range strings.Split(args[2], ",") {
			f = strings.TrimSpace(f)
			if f == "" {
				continue
			}
			filter[f] = true
		}
	}

	fset := token.NewFileSet()
	cfg := &packages.Config{
		Mode:  packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedImports,
		Fset:  fset,
		Tests: includeTests, // This tells packages.Load to include test files
	}

	pkgs, err := packages.Load(cfg, srcPkg)
	if err != nil {
		log.Fatalf("packages.Load: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		log.Fatalf("errors loading package")
	}

	if len(pkgs) == 0 {
		log.Fatalf("no packages found for %s", srcPkg)
	}

	// ensure output dir exists
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		log.Fatalf("mkdir outdir: %v", err)
	}

	outPkgName := filepath.Base(outDir)

	// Process all loaded packages (regular + test if requested)
	for _, pkg := range pkgs {
		// pkg.GoFiles and pkg.Syntax are parallel slices
		for i, srcPath := range pkg.GoFiles {
			base := filepath.Base(srcPath)

			// only include .go source files
			if !strings.HasSuffix(base, ".go") {
				continue
			}

			nameNoExt := strings.TrimSuffix(base, ".go")
			if filter != nil {
				if !filter[nameNoExt] {
					continue
				}
			}

			file := pkg.Syntax[i]

			// mutate package name on the AST file
			if file.Name != nil {
				file.Name.Name = outPkgName
			}

			// Print the altered file AST into buffer
			buf := &bytes.Buffer{}
			if err := printer.Fprint(buf, fset, file); err != nil {
				log.Fatalf("printer.Fprint %s: %v", srcPath, err)
			}

			outSrc, err := format.Source(buf.Bytes())
			if err != nil {
				// If formatting fails, keep unformatted output to aid debugging
				log.Printf("format.Source failed for %s: %v", srcPath, err)
				outSrc = buf.Bytes()
			}

			outBase := base
			if !strings.HasPrefix(base, "zz_generated.copied.") {
				outBase = "zz_generated.copied." + base
			}
			// Ensure generated header is the first line
			header := []byte("// Code generated by copycode. DO NOT EDIT.\n\n")
			if !bytes.HasPrefix(outSrc, header) {
				outSrc = append(header, outSrc...)
			}

			outPath := filepath.Join(outDir, outBase)
			if err := os.WriteFile(outPath, outSrc, 0o644); err != nil {
				log.Fatalf("write file %s: %v", outPath, err)
			}
			fmt.Printf("wrote %s\n", outPath)
		}
	}
}
